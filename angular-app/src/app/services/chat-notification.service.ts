/* eslint-disable */
/* Code generated by ng-openapi-gen DO NOT EDIT. */

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Api } from './chat-services/api';

// Import notification functions
import { deleteNotification, getUserNotifications } from './chat-services/functions';
import { getUnreadUserNotifications } from './chat-services/functions';
import { getUnreadNotificationCount } from './chat-services/functions';
import { markAsRead } from './chat-services/functions';
import { markAllAsRead } from './chat-services/functions';

// Import DTOs
import { NotificationDto } from './chat-services/models/notification-dto';

/**
 * Service to handle notifications from chat-service only
 */
@Injectable({ providedIn: 'root' })
export class ChatNotificationService {

  constructor(
    private api: Api,
    private http: HttpClient,
     ) {
    
  }

  /**
   * Get all notifications from chat service
   * @returns Array of chat notifications
   */
  async getAllNotifications(): Promise<NotificationDto[]> {
    try {
      const response = await this.api.invoke(getUserNotifications);
      // Handle blob response by parsing JSON
      if (response instanceof Blob) {
        const text = await response.text();
        return JSON.parse(text);
      }
      return Array.isArray(response) ? response : [];
    } catch (error) {
      console.error('Error fetching chat notifications:', error);
      return [];
    }
  }

  /**
   * Get unread notifications from chat service
   * @returns Array of unread chat notifications
   */
  async getUnreadNotifications(): Promise<NotificationDto[]> {
    try {
      const response = await this.api.invoke(getUnreadUserNotifications);
      // Handle blob response by parsing JSON
      if (response instanceof Blob) {
        const text = await response.text();
        return JSON.parse(text);
      }
      return Array.isArray(response) ? response : [];
    } catch (error) {
      console.error('Error fetching unread chat notifications:', error);
      return [];
    }
  }

  /**
   * Get count of unread notifications from chat service
   * @returns Unread count
   */
  async getUnreadCount(): Promise<number> {
    try {
      const response = await this.api.invoke(getUnreadNotificationCount);
      console.log(response);
      return response as unknown as number;
    } catch (error) {
      console.error('Error fetching unread count:', error);
      return 0;
    }
  }

  /**
   * Mark a notification as read
   * @param id Notification ID
   */
  async markAsRead(id: number): Promise<void> {
    try {
      await this.api.invoke(markAsRead, { notificationId: id });
    } catch (error) {
      console.error('Error marking notification as read:', error);
      throw error;
    }
  }

  /**
   * Mark all notifications as read
   */
  async markAllAsRead(): Promise<void> {
    try {
      await this.api.invoke(markAllAsRead);
    } catch (error) {
      console.error('Error marking all notifications as read:', error);
      throw error;
    }
  }

  /**
   * Delete a notification
   * @param id Notification ID to delete
   */
  async deleteNotification(id: number): Promise<void> {
    try {
      console.log('Deleting chat notification with id:', id);
      await this.api.invoke(deleteNotification, { notificationId: id });
      
      // Verify the notification was actually removed
      const allNotifications = await this.getAllNotifications();
      const notificationStillExists = allNotifications.some(n => n.id === id);
      
      if (notificationStillExists) {
        console.warn('Notification was not actually deleted from backend:', id);
      } else {
        console.log('Notification successfully removed from backend:', id);
      }
      
      console.log('Successfully deleted chat notification:', id);
    } catch (error) {
      console.error('Error deleting chat notification:', error);
      throw error;
    }
  }
}