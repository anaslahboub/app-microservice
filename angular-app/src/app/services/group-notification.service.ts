/* eslint-disable */
/* Code generated by ng-openapi-gen DO NOT EDIT. */

import { Injectable } from '@angular/core';
import { HttpClient, HttpContext, HttpResponse } from '@angular/common/http';
import { Observable, firstValueFrom } from 'rxjs';
import { filter, map } from 'rxjs/operators';
import { ApiConfiguration } from '../group-services/api-configuration';
import { StrictHttpResponse } from '../group-services/strict-http-response';
import { Api } from '../group-services/api';

// Import notification functions
import { deleteNotification, getUserNotifications } from '../group-services/functions';
import { getUnreadUserNotifications } from '../group-services/functions';
import { getUnreadNotificationCount } from '../group-services/functions';
import { markAsRead } from '../group-services/functions';
import { markAllAsRead } from '../group-services/functions';

// Import DTOs
import { NotificationDto } from '../group-services/models/notification-dto';

/**
 * Service to handle notifications from group-service only
 */
@Injectable({ providedIn: 'root' })
export class GroupNotificationService {

  constructor(
    private api:Api,
    private http: HttpClient,

  ) {
  }

  /**
   * Get all notifications from group service
   * @returns Array of group notifications
   */
  async getAllNotifications(): Promise<NotificationDto[]> {
    try {
      const response = await this.api.invoke(getUserNotifications);
      // Handle blob response by parsing JSON
      if (response instanceof Blob) {
        const text = await response.text();
        return JSON.parse(text);
      }
      return Array.isArray(response) ? response : [];
    } catch (error) {
      console.error('Error fetching group notifications:', error);
      return [];
    }
  }

  /**
   * Get unread notifications from group service
   * @returns Array of unread group notifications
   */
  async getUnreadNotifications(): Promise<NotificationDto[]> {
    try {
      const response = await this.api.invoke(getUnreadUserNotifications);
      // Handle blob response by parsing JSON
      if (response instanceof Blob) {
        const text = await response.text();
        return JSON.parse(text);
      }
      return Array.isArray(response) ? response : [];
    } catch (error) {
      console.error('Error fetching unread group notifications:', error);
      return [];
    }
  }

  /**
   * Get count of unread notifications from group service
   * @returns Unread count
   */
  async getUnreadCount(): Promise<number> {
    try {
      const response = await this.api.invoke(getUnreadNotificationCount);
      
      // Check if response is a Blob (which needs special handling)
      if (response && typeof response === 'object' && 'text' in response) {
        // This is likely a Blob or similar object
        const text = await (response as unknown as Blob).text();
        return parseFloat(text);
      }
      
      // Otherwise treat as direct number response
      return response as unknown as number;
    } catch (error) {
      console.error('Error fetching unread count:', error);
      return 0;
    }
  }

  /**
   * Mark a notification as read
   * @param id Notification ID
   */
  async markAsRead(id: number): Promise<void> {
    try {
      await this.api.invoke(markAsRead, { notificationId: id });
      console.log(`Notification ${id} marked as read.`);
    } catch (error) {
      console.error('Error marking notification as read:', error);
      throw error;
    }
  }

  /**
   * Mark all notifications as read
   */
  async markAllAsRead(): Promise<void> {
    try {
      await this.api.invoke(markAllAsRead);
      console.log('All notifications marked as read.');
    } catch (error) {
      console.error('Error marking all notifications as read:', error);
      throw error;
    }
  }

  /**
   * Delete a notification
   * @param id Notification ID to delete
   */
  async deleteNotification(id: number): Promise<void> {
    try {
      console.log('Deleting group notification with id:', id);
      await this.api.invoke(deleteNotification, { notificationId: id });
      
      // Verify the notification was actually removed
      const allNotifications = await this.getAllNotifications();
      const notificationStillExists = allNotifications.some(n => n.id === id);
      
      if (notificationStillExists) {
        console.warn('Notification was not actually deleted from backend:', id);
      } else {
        console.log('Notification successfully removed from backend:', id);
      }
      
      console.log('Successfully deleted group notification:', id);
    } catch (error) {
      console.error('Error deleting group notification:', error);
      throw error;
    }
  }
}